#+TITLE: Introduction to Haskell
#+REVEAL_THEME: night
#+OPTIONS: toc:nil, num:nil, timestamp:nil
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js@3.8.0

* What is Haskell?

** Haskell is a programming language that
#+ATTR_REVEAL: :frag (roll-in)
- is pure
- is lazy
- has immutable data
- is used to build programs by composing functions
  - show how it's similar to unix pipes as in [[https://www.youtube.com/watch?v=b9FagOVqxmI][this video]].

** First, Something Familiar
#+begin_src shell
$ cat world.txt
I see trees of green
Red roses too
I see them bloom
For me and for you
And I think to myself
What a wonderful world
#+end_src
#+begin_src bash :results pp
$ cat world.txt | sort | rev | tr '[:lower:]' '[:upper:]'
FLESYM OT KNIHT I DNA
UOY ROF DNA EM ROF
MOOLB MEHT EES I
NEERG FO SEERT EES I
OOT SESOR DER
DLROW LUFREDNOW A TAHW
#+end_src

#+results:

** In Haskell
#+ATTR_REVEAL: :frag roll-in
#+begin_src haskell
main = readFile "world.txt" >>= putStr . sortRevUpper

sortRevUpper s = (map toUpper (unlines (map reverse (sort (lines s)))))
#+end_src

** Function Composition
Compose two functions using '.'
#+begin_src
f (g x) = (f . g) x
#+end_src

#+ATTR_REVEAL: :frag roll-in
#+begin_block
So
#+begin_src haskell
sortRevUpper s = (map toUpper (unlines (map reverse (sort (lines s)))))
#+end_src
#+end_block

#+ATTR_REVEAL: :frag roll-in
#+begin_block
becomes
#+begin_src haskell
sortRevUpper s = (map toUpper . unlines . map reverse . sort . lines) s
#+end_src
#+end_block

#+ATTR_REVEAL: :frag roll-in
#+begin_block
which becomes
#+begin_src haskell
sortRevUpper = map toUpper . unlines . map reverse . sort . lines
#+end_src
#+end_block

** Defining Our Own Functions
Let's define some helper functions.
#+begin_src haskell
allUpper :: String -> String
allUpper = map toUpper

rev :: [String] -> [String]
rev = map reverse

sortRevUpper =  allUpper . unlines . rev . sort . lines
#+end_src

** Haskell is Pure
#+ATTR_REVEAL: :frag (roll-in)
- This means that functions _always_ return the same output for a given set of inputs, and
- they have no side effects

** Haskell is lazy
#+ATTR_REVEAL: :frag (roll-in)
- data is only created as it is needed

*** TODO perhaps show definition of Fibonacci sequence as in [[https://www.youtube.com/watch?v=apBWkBDVlow][this video]].

#+ATTR_REVEAL: :frag roll-in
#+begin_src haskell :results pp
-- an infinite list
xs = [1..]

-- take the first 10
take 10 xs
#+end_src

#+results: 
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |

* Why Haskell is Cool
- A new way to think about programming
- expressive, concise and clear
- beautiful
